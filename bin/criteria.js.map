{
  "version": 3,
  "sources": ["../src/helpers/walkDir.ts", "../src/helpers/ansi.ts", "../src/helpers/args.ts", "../src/cli.ts"],
  "sourcesContent": ["//  Library\r\nimport * as fs from 'fs'\r\nimport * as path from 'path'\r\n\r\n//  ==============\r\n//  WALK DIRECTORY\r\n//  ==============\r\n\r\n/**\r\n * Walks the provided path and executes the callback function\r\n * @param dir Path to directory\r\n * @param callback Callback function to execute for every entry\r\n */\r\nexport function walkDir(dir: string, callback: (x: string) => void) {\r\n    fs.readdirSync(dir).forEach(f => {\r\n        const dirPath = path.join(dir, f)\r\n        const isDirectory = fs.statSync(dirPath).isDirectory()\r\n        isDirectory\r\n            ? walkDir(dirPath, callback)\r\n            : callback(path.join(dir, f))\r\n    })\r\n}", "//  ==========\r\n//  ANSI CODES\r\n//  ==========\r\n\r\nexport const ESC = '\\u001b'\r\nexport const RESET = `${ESC}[0m`\r\n\r\n/**\r\n * Helper function to wrap the given string with the given ansi code tuple\r\n * @param str Text to wrap ANSI code around\r\n * @param code Tuple representing the ANSI start and end codes [start, end]\r\n */\r\nfunction wrap(str: string, code: [string, string]) { return `${code[0]}${str}${code[1]}` }\r\n\r\n/** ANSI Code Utilities */\r\nexport const ansi = {\r\n    /** Wraps the text in ANSI bold codes */\r\n    bold: (str: string) => wrap(str, [`${ESC}[1m`, `${ESC}[22m`]),\r\n    /** Wraps the text in ANSI inverse codes */\r\n    inverse: (str: string) => wrap(str, [`${ESC}[7m`, `${ESC}[27m`]),\r\n    /** Returns a curried function that inturn wraps a text in n whitespaces */\r\n    pad: (n: number = 1) => (str: string) => wrap(str, [' '.repeat(n), ' '.repeat(n)]),\r\n    /** Returns a curried function that inturn wraps a text in n newlines */\r\n    margin: (n: number = 1) => (str: string) => wrap(str, ['\\n'.repeat(n), '\\n'.repeat(n)]),\r\n    /** Wraps the text in ANSI green codes */\r\n    green: (str: string) => wrap(str, [`${ESC}[32m`, `${ESC}[39m`]),\r\n    /** Wraps the text in ANSI red codes */\r\n    red: (str: string) => wrap(str, [`${ESC}[31m`, `${ESC}[39m`]),\r\n}\r\n", "//  ====\r\n//  ARGS\r\n//  ====\r\n\r\n/**\r\n * Retrieves the cli-arguments from process.argv\r\n * @returns The array of cli arguments\r\n */\r\n export const getArguments = () => process.argv.slice(2)\r\n\r\n type ParsedArguments = {\r\n     arguments: string[],\r\n     flags: { [key: string]: any }\r\n }\r\n \r\n /**\r\n  * Parses the command line arguments\r\n  * @param args Array of CLI arguments\r\n  */\r\n export const parseArguments = (...args: string[]): ParsedArguments => {\r\n \r\n     //  Get arguments from process.argv if none are passed int\r\n     if (!args || !args.length) {\r\n         args = getArguments()\r\n     }\r\n \r\n     //  Handle variadic arguments as well as a single array\r\n     if (args.length === 1 && Array.isArray(args[0])) {\r\n         args = args[0]\r\n     }\r\n \r\n     const result: ParsedArguments = { arguments: [], flags: {} }\r\n \r\n     //  Iterate over all arguments\r\n     for (let i = 0; i < args.length; i++) {\r\n \r\n         //  If the argument is not a flag...\r\n         if (!args[i].startsWith('-')) {\r\n             result.arguments.push(args[i])  //  ... add it to the arguments array\r\n         }\r\n \r\n         //  If the argument starts with --\r\n         if (args[i].startsWith('--')) {\r\n             //  Extract key=value using regex\r\n             let match = args[i].substring(2).match(/^([\\w\\-]+)=?(\\w*)$/im)\r\n \r\n             if (!match) { continue }  //  Return if match is not found\r\n \r\n             let [, key, value] = match as [input: string, key: string, value?: string | boolean]\r\n \r\n             //  If the value is not defined and the next argument exists and is not a flag...\r\n             if (!value && args.length > i + 1 && !args[i + 1].startsWith('-')) {\r\n                 value = args[i + 1] //  ... assign it as the value for the current flag\r\n                 i = i + 1   //  Skip the next iteration\r\n             }\r\n \r\n             value = value || true   //  Default to true if value is undefined\r\n             result.flags[key] = value   //  Set flag\r\n         }\r\n \r\n         //  If the argument starts with -\r\n         else if (args[i].startsWith('-')) {\r\n             //  Extract k=value using regex\r\n             let match = args[i].substring(1).match(/([\\w\\-]{1})=?(\\w*)/im)\r\n \r\n             if (!match) { continue }  //  Return if match is not found\r\n \r\n             let [, key, value] = match as [input: string, flagName: string, value?: string | boolean]\r\n \r\n             //  If the value is not defined and the next argument exists and it is not a flag...\r\n             if (!value && args.length > i + 1 && !args[i + 1].startsWith('-')) {\r\n                 value = args[i + 1] //  ...assign it as the value to the current flag\r\n                 i = i + 1   //  Skip the next iteration\r\n             }\r\n \r\n             value = value || true   //  Default to true if value is undefined\r\n             result.flags[key] = value   //  Set flag\r\n         }\r\n \r\n     }\r\n \r\n     return result\r\n \r\n }", "//  Library\r\nimport { walkDir, ansi, parseArguments } from './helpers'\r\nimport * as path from 'path'\r\n\r\n/** File-extensions to look for tests */\r\nconst fileExtension = /\\.(test|spec)\\.(js|ts)$/\r\n\r\n//  Parse Command-Line Arguments\r\nconst args = parseArguments()\r\nconst dir = path.join(process.cwd(), args.arguments[0] || 'tests')\r\n\r\n//  Walk over the current directory and require all test files\r\nconst done: string[] = []\r\nwalkDir(dir, (x) => {\r\n    if (fileExtension.test(x)) {\r\n        const fileName = path.basename(x).replace(fileExtension, '')\r\n        if (!fileName || done.includes(fileName)) { return }    //  If a test with the same fileName is already done then skip it\r\n        done.push(fileName)\r\n        console.log('loading: ' + x.replace(fileName, ansi.bold(fileName)))\r\n        //  Iterate over the map and run all test suites\r\n        require(x)\r\n    }\r\n})"],
  "mappings": "ohBACA,MAAoB,iBACpB,EAAsB,mBAWf,WAAiB,EAAa,EAA+B,CAChE,AAAG,cAAY,GAAK,QAAQ,GAAK,CAC7B,GAAM,GAAU,AAAK,OAAK,EAAK,GAE/B,AADoB,AAAG,WAAS,GAAS,cAEnC,EAAQ,EAAS,GACjB,EAAS,AAAK,OAAK,EAAK,MCf/B,GAAM,GAAM,IACN,EAAQ,GAAG,OAOxB,WAAc,EAAa,EAAwB,CAAE,MAAO,GAAG,EAAK,KAAK,IAAM,EAAK,KAG7E,GAAM,GAAO,CAEhB,KAAM,AAAC,GAAgB,EAAK,EAAK,CAAC,GAAG,OAAU,GAAG,UAElD,QAAS,AAAC,GAAgB,EAAK,EAAK,CAAC,GAAG,OAAU,GAAG,UAErD,IAAK,CAAC,EAAY,IAAM,AAAC,GAAgB,EAAK,EAAK,CAAC,IAAI,OAAO,GAAI,IAAI,OAAO,KAE9E,OAAQ,CAAC,EAAY,IAAM,AAAC,GAAgB,EAAK,EAAK,CAAC;AAAA,EAAK,OAAO,GAAI;AAAA,EAAK,OAAO,KAEnF,MAAO,AAAC,GAAgB,EAAK,EAAK,CAAC,GAAG,QAAW,GAAG,UAEpD,IAAK,AAAC,GAAgB,EAAK,EAAK,CAAC,GAAG,QAAW,GAAG,WCnB9C,GAAM,GAAe,IAAM,QAAQ,KAAK,MAAM,GAWxC,EAAiB,IAAI,IAAoC,CAGlE,AAAI,EAAC,GAAQ,CAAC,EAAK,SACf,GAAO,KAIP,EAAK,SAAW,GAAK,MAAM,QAAQ,EAAK,KACxC,GAAO,EAAK,IAGhB,GAAM,GAA0B,CAAE,UAAW,GAAI,MAAO,IAGxD,OAAS,GAAI,EAAG,EAAI,EAAK,OAAQ,IAQ7B,GALK,EAAK,GAAG,WAAW,MACpB,EAAO,UAAU,KAAK,EAAK,IAI3B,EAAK,GAAG,WAAW,MAAO,CAE1B,GAAI,GAAQ,EAAK,GAAG,UAAU,GAAG,MAAM,wBAEvC,GAAI,CAAC,EAAS,SAEd,GAAI,CAAC,CAAE,EAAK,GAAS,EAGrB,AAAI,CAAC,GAAS,EAAK,OAAS,EAAI,GAAK,CAAC,EAAK,EAAI,GAAG,WAAW,MACzD,GAAQ,EAAK,EAAI,GACjB,EAAI,EAAI,GAGZ,EAAQ,GAAS,GACjB,EAAO,MAAM,GAAO,UAIf,EAAK,GAAG,WAAW,KAAM,CAE9B,GAAI,GAAQ,EAAK,GAAG,UAAU,GAAG,MAAM,wBAEvC,GAAI,CAAC,EAAS,SAEd,GAAI,CAAC,CAAE,EAAK,GAAS,EAGrB,AAAI,CAAC,GAAS,EAAK,OAAS,EAAI,GAAK,CAAC,EAAK,EAAI,GAAG,WAAW,MACzD,GAAQ,EAAK,EAAI,GACjB,EAAI,EAAI,GAGZ,EAAQ,GAAS,GACjB,EAAO,MAAM,GAAO,EAK5B,MAAO,IC/EZ,MAAsB,mBAGhB,EAAgB,0BAGhB,EAAO,IACP,EAAM,AAAK,OAAK,QAAQ,MAAO,EAAK,UAAU,IAAM,SAGpD,EAAiB,GACvB,EAAQ,EAAK,AAAC,GAAM,CAChB,GAAI,EAAc,KAAK,GAAI,CACvB,GAAM,GAAW,AAAK,WAAS,GAAG,QAAQ,EAAe,IACzD,GAAI,CAAC,GAAY,EAAK,SAAS,GAAa,OAC5C,EAAK,KAAK,GACV,QAAQ,IAAI,YAAc,EAAE,QAAQ,EAAU,EAAK,KAAK,KAExD,QAAQ",
  "names": []
}
