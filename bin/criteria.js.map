{
  "version": 3,
  "sources": ["../src/helpers/walkDir.ts", "../src/helpers/ansi.ts", "../src/helpers/args.ts", "../src/cli.ts"],
  "sourcesContent": ["//  Library\r\nimport * as fs from 'fs'\r\nimport * as path from 'path'\r\n\r\n//  ==============\r\n//  WALK DIRECTORY\r\n//  ==============\r\n\r\n/**\r\n * Walks the provided path and executes the callback function\r\n * @param dir Path to directory\r\n * @param callback Callback function to execute for every entry\r\n */\r\nexport function walkDir(dir: string, callback: (x: string) => void) {\r\n    fs.readdirSync(dir).forEach(f => {\r\n        const dirPath = path.join(dir, f)\r\n        const isDirectory = fs.statSync(dirPath).isDirectory()\r\n        isDirectory\r\n            ? walkDir(dirPath, callback)\r\n            : callback(path.join(dir, f))\r\n    })\r\n}", "//  ==========\r\n//  ANSI CODES\r\n//  ==========\r\n\r\nexport const ESC = '\\u001b'\r\nexport const RESET = `${ESC}[0m`\r\n\r\n/**\r\n * Helper function to wrap the given string with the given ansi code tuple\r\n * @param str Text to wrap ANSI code around\r\n * @param code Tuple representing the ANSI start and end codes [start, end]\r\n */\r\nfunction wrap(str: string, code: [string, string]) { return `${code[0]}${str}${code[1]}` }\r\n\r\n/** ANSI Code Utilities */\r\nexport const ansi = {\r\n    /** Wraps the text in ANSI bold codes */\r\n    bold: (str: string) => wrap(str, [`${ESC}[1m`, `${ESC}[22m`]),\r\n    /** Wraps the text in ANSI inverse codes */\r\n    inverse: (str: string) => wrap(str, [`${ESC}[7m`, `${ESC}[27m`]),\r\n    /** Returns a curried function that inturn wraps a text in n whitespaces */\r\n    pad: (n: number = 1) => (str: string) => wrap(str, [' '.repeat(n), ' '.repeat(n)]),\r\n    /** Returns a curried function that inturn wraps a text in n newlines */\r\n    margin: (n: number = 1) => (str: string) => wrap(str, ['\\n'.repeat(n), '\\n'.repeat(n)]),\r\n    /** Wraps the text in ANSI green codes */\r\n    green: (str: string) => wrap(str, [`${ESC}[32m`, `${ESC}[39m`]),\r\n    /** Wraps the text in ANSI red codes */\r\n    red: (str: string) => wrap(str, [`${ESC}[31m`, `${ESC}[39m`]),\r\n}\r\n", "//  ====\r\n//  ARGS\r\n//  ====\r\n\r\n/**\r\n * Retrieves the cli-arguments from process.argv\r\n * @returns The array of cli arguments\r\n */\r\n export const getArguments = () => process.argv.slice(2)\r\n\r\n type ParsedArguments = {\r\n     arguments: string[],\r\n     flags: { [key: string]: any }\r\n }\r\n \r\n /**\r\n  * Parses the command line arguments\r\n  * @param args Array of CLI arguments\r\n  */\r\n export const parseArguments = (...args: string[]): ParsedArguments => {\r\n \r\n     //  Get arguments from process.argv if none are passed int\r\n     if (!args || !args.length) {\r\n         args = getArguments()\r\n     }\r\n \r\n     //  Handle variadic arguments as well as a single array\r\n     if (args.length === 1 && Array.isArray(args[0])) {\r\n         args = args[0]\r\n     }\r\n \r\n     const result: ParsedArguments = { arguments: [], flags: {} }\r\n \r\n     //  Iterate over all arguments\r\n     for (let i = 0; i < args.length; i++) {\r\n \r\n         //  If the argument is not a flag...\r\n         if (!args[i].startsWith('-')) {\r\n             result.arguments.push(args[i])  //  ... add it to the arguments array\r\n         }\r\n \r\n         //  If the argument starts with --\r\n         if (args[i].startsWith('--')) {\r\n             //  Extract key=value using regex\r\n             let match = args[i].substring(2).match(/^([\\w\\-]+)=?(\\w*)$/im)\r\n \r\n             if (!match) { continue }  //  Return if match is not found\r\n \r\n             let [, key, value] = match as [input: string, key: string, value?: string | boolean]\r\n \r\n             //  If the value is not defined and the next argument exists and is not a flag...\r\n             if (!value && args.length > i + 1 && !args[i + 1].startsWith('-')) {\r\n                 value = args[i + 1] //  ... assign it as the value for the current flag\r\n                 i = i + 1   //  Skip the next iteration\r\n             }\r\n \r\n             value = value || true   //  Default to true if value is undefined\r\n             result.flags[key] = value   //  Set flag\r\n         }\r\n \r\n         //  If the argument starts with -\r\n         else if (args[i].startsWith('-')) {\r\n             //  Extract k=value using regex\r\n             let match = args[i].substring(1).match(/([\\w\\-]{1})=?(\\w*)/im)\r\n \r\n             if (!match) { continue }  //  Return if match is not found\r\n \r\n             let [, key, value] = match as [input: string, flagName: string, value?: string | boolean]\r\n \r\n             //  If the value is not defined and the next argument exists and it is not a flag...\r\n             if (!value && args.length > i + 1 && !args[i + 1].startsWith('-')) {\r\n                 value = args[i + 1] //  ...assign it as the value to the current flag\r\n                 i = i + 1   //  Skip the next iteration\r\n             }\r\n \r\n             value = value || true   //  Default to true if value is undefined\r\n             result.flags[key] = value   //  Set flag\r\n         }\r\n \r\n     }\r\n \r\n     return result\r\n \r\n }", "//  Library\r\nimport { walkDir, ansi, parseArguments } from './helpers'\r\nimport * as path from 'path'\r\n\r\n/** File-extensions to look for tests */\r\nconst fileExtension = /\\.(test|spec)\\.(js|ts)$/\r\n\r\n//  Parse Command-Line Arguments\r\nconst args = parseArguments()\r\nconst dir = path.join(process.cwd(), args.arguments[0] || 'tests')\r\n\r\n//  Walk over the current directory and require all test files\r\nconst done: string[] = []\r\nwalkDir(dir, (x) => {\r\n    if (fileExtension.test(x)) {\r\n        const fileName = path.basename(x).replace(fileExtension, '')\r\n        if (!fileName || done.includes(fileName)) { return }    //  If a test with the same fileName is already done then skip it\r\n        done.push(fileName)\r\n        console.log('loading: ' + x.replace(fileName, ansi.bold(fileName)))\r\n        //  Iterate over the map and run all test suites\r\n        require(x)\r\n    }\r\n})"],
  "mappings": "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",
  "names": ["dir", "args", "path"]
}
